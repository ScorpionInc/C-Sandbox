/* template.template
 * Purpose: Class-like template generation using preprocessor #defines
 * Created: 20250623
 * Updated: 20250623
//*/

#include "si_linked_list.h"

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#ifdef SI_TEMPLATE_TYPE

#ifndef _STRINGIFY
#define _STRINGIFY(s) #s
#define DEFINED__STRINGIFY
#endif
#ifndef STRINGIFY
#define STRINGIFY(s) _STRINGIFY(s)
#define DEFINED_STRINGIFY
#endif

#ifndef PASTE_TWO_TOKENS
#define PASTE_TWO_TOKENS(token_1, token_2) token_1 ## token_2
#define DEFINED_PASTE_TWO_TOKENS
#endif
#ifndef PASTE_TWO_TOKENS_INDIRECT
#define PASTE_TWO_TOKENS_INDIRECT(token_1, token_2) PASTE_TWO_TOKENS(token_1 , token_2)
#define DEFINED_PASTE_TWO_TOKENS_INDIRECT
#endif

// Used to generate function/struct type names using provided template_type
#ifdef SI_TEMPLATE_FUNCTION
#undef SI_TEMPLATE_FUNCTION
#endif
#define SI_TEMPLATE_FUNCTION(B, E) \
	PASTE_TWO_TOKENS_INDIRECT(B, \
	PASTE_TWO_TOKENS_INDIRECT(SI_TEMPLATE_TYPE, E))


typedef struct si_linked_list_t SI_TEMPLATE_FUNCTION(, _linked_list);

static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_grow_by)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const size_t amount)
{
	si_linked_list_grow_by(p_list, amount);
}

static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_grow_to)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const size_t capacity)
{
	si_linked_list_grow_to(p_list, capacity);
}

static inline void SI_TEMPLATE_FUNCTION(, _linked_list_new_2)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const size_t initial_capacity)
{
	si_linked_list_new_2(p_list, initial_capacity);
}

static inline void SI_TEMPLATE_FUNCTION(, _linked_list_new)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list)
{
	si_linked_list_new(p_list);
}

static inline size_t SI_TEMPLATE_FUNCTION(, _linked_list_count)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list)
{
	return si_linked_list_count(p_list);
}

static inline size_t SI_TEMPLATE_FUNCTION(, _linked_list_capacity)(
		const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list)
{
	return si_linked_list_capacity(p_list);
}

static inline SI_TEMPLATE_FUNCTION(, _linked_list)* SI_TEMPLATE_FUNCTION(, _linked_list_node_at)(
		const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
		const size_t index)
{
	return si_linked_list_node_at(p_list, index);
}

static inline si_dynamic* SI_TEMPLATE_FUNCTION(, _linked_list_at)(
		const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
		const size_t index)
{
	return si_linked_list_at(p_list, index);
}

static inline SI_TEMPLATE_TYPE* SI_TEMPLATE_FUNCTION(, _linked_list_raw_at)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const size_t index)
{
	return (SI_TEMPLATE_TYPE*)si_linked_list_raw_at(p_list, index);
}

static inline size_t SI_TEMPLATE_FUNCTION(, _linked_list_find_3)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const si_dynamic* const p_data, const size_t start_index)
{
	return si_linked_list_find_3(p_list, p_data, start_index);
}
static inline size_t SI_TEMPLATE_FUNCTION(, _linked_list_find)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const si_dynamic* const p_data)
{
	return si_linked_list_find(p_list, p_data);
}

static inline size_t SI_TEMPLATE_FUNCTION(, _linked_list_find_raw_3)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const SI_TEMPLATE_TYPE needle, const size_t start_index)
{
	return si_linked_list_find_raw_4(
		p_list, &needle, sizeof(SI_TEMPLATE_TYPE), start_index
	);
}
static inline size_t SI_TEMPLATE_FUNCTION(, _linked_list_find_raw)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const SI_TEMPLATE_TYPE needle)
{
	return si_linked_list_find_raw(p_list, &needle, sizeof(SI_TEMPLATE_TYPE));
}

static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_assign_5)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const si_dynamic* const p_dynamic, const bool deep_copy,
	const bool do_free, const size_t index)
{
	return si_linked_list_assign_5(p_list, p_dynamic, deep_copy, do_free, index);
}
static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_assign_4)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const si_dynamic* const p_dynamic, const bool deep_copy,
	const bool do_free)
{
	return si_linked_list_assign_4(p_list, p_dynamic, deep_copy, do_free);
}
static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_assign_3)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const si_dynamic* const p_dynamic, const bool deep_copy)
{
	return si_linked_list_assign_3(p_list, p_dynamic, deep_copy);
}
static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_assign)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	const si_dynamic* const p_dynamic)
{
	return si_linked_list_assign(p_list, p_dynamic);
}

// TODO insert next dynamics

static bool SI_TEMPLATE_FUNCTION(, _linked_list_insert_next_raw)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list, const SI_TEMPLATE_TYPE data)
{
	return si_linked_list_insert_next_raw(p_list, &data, sizeof(SI_TEMPLATE_TYPE));
}

// TODO insert dynamics

static bool SI_TEMPLATE_FUNCTION(, _linked_list_insert_raw)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list, const SI_TEMPLATE_TYPE data,
	const size_t index)
{
	return si_linked_list_insert_raw(p_list, &data, sizeof(SI_TEMPLATE_TYPE), index);
}

static inline SI_TEMPLATE_FUNCTION(, _linked_list)* SI_TEMPLATE_FUNCTION(, _linked_list_last_node)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list)
{
	return si_linked_list_last_node(p_list);
}

// TODO append dynamics

static bool SI_TEMPLATE_FUNCTION(, _linked_list_append_raw)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list, const SI_TEMPLATE_TYPE data)
{
	return si_linked_list_append_raw(p_list, &data, sizeof(SI_TEMPLATE_TYPE));
}

// TODO do_free
static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_remove_next)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list)
{
	return si_linked_list_remove_next(p_list);
}

// TODO do_free
static inline bool SI_TEMPLATE_FUNCTION(, _linked_list_remove_at)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list, const size_t index)
{
	return si_linked_list_remove_at(p_list, index);
}

static inline void SI_TEMPLATE_FUNCTION(, _linked_list_free)(
	SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list)
{
	si_linked_list_free(p_list);
}

static inline void SI_TEMPLATE_FUNCTION(, _linked_list_fprint)(
	const SI_TEMPLATE_FUNCTION(, _linked_list)* const p_list,
	FILE* const p_file)
{
	si_linked_list_fprint(p_list, p_file);
}


// Clean up our preprocessor defines.
#undef SI_TEMPLATE_FUNCTION

// Only undefine these functions if they weren't already defined
// Done in the reverse order of their definition.
#ifdef DEFINED_PASTE_TWO_TOKENS_INDIRECT
#undef PASTE_TWO_TOKENS_INDIRECT
#undef DEFINED_PASTE_TWO_TOKENS_INDIRECT
#endif

#ifdef DEFINED_PASTE_TWO_TOKENS
#undef PASTE_TWO_TOKENS
#undef DEFINED_PASTE_TWO_TOKENS
#endif

#ifdef DEFINED_STRINGIFY
#undef STRINGIFY
#undef DEFINED_STRINGIFY
#endif

#ifdef DEFINED__STRINGIFY
#undef _STRINGIFY
#undef DEFINED__STRINGIFY
#endif

#undef SI_TEMPLATE_TYPE

#else

// Handle undefined template type.
#error "Template was included without a defined template type(SI_TEMPLATE_TYPE)."

#endif//SI_TEMPLATE_TYPE

#ifdef __cplusplus
}
#endif //__cplusplus
